/**
 * Script Compiler - Compiles visual scripts to Frida JavaScript code
 *
 * This module transforms the visual node graph into executable Frida JavaScript
 * that can be injected into a target process.
 */

import { Script, ScriptNode } from "../stores/script";
import { UIComponent } from "../stores/designer";

// ============================================
// Types
// ============================================

export interface CompileResult {
  success: boolean;
  code: string;
  errors: CompileError[];
  warnings: string[];
}

export interface CompileError {
  nodeId?: string;
  message: string;
}

interface CompileContext {
  script: Script;
  uiComponents: UIComponent[];
  output: string[];
  indent: number;
  errors: CompileError[];
  warnings: string[];
  visitedNodes: Set<string>;
  variables: Map<string, string>; // variable id -> runtime name
  nodeOutputs: Map<string, Map<string, string>>; // nodeId -> portName -> expression
}

// ============================================
// Main Compiler Function
// ============================================

export function compileVisualScript(
  script: Script,
  uiComponents: UIComponent[],
): CompileResult {
  const ctx: CompileContext = {
    script,
    uiComponents,
    output: [],
    indent: 0,
    errors: [],
    warnings: [],
    visitedNodes: new Set(),
    variables: new Map(),
    nodeOutputs: new Map(),
  };

  try {
    // Generate header
    emitHeader(ctx);

    // Generate UI state object
    emitUIState(ctx);

    // Find all event nodes (entry points)
    const eventNodes = script.nodes.filter((n) => n.type.startsWith("event_"));

    if (eventNodes.length === 0) {
      ctx.warnings.push("No event nodes found. Script will not execute.");
    }

    // Generate event handlers
    for (const eventNode of eventNodes) {
      emitEventHandler(ctx, eventNode);
    }

    // Generate RPC exports
    emitRpcExports(ctx, eventNodes);

    // Generate footer
    emitFooter(ctx);

    return {
      success: ctx.errors.length === 0,
      code: ctx.output.join("\n"),
      errors: ctx.errors,
      warnings: ctx.warnings,
    };
  } catch (e) {
    return {
      success: false,
      code: "",
      errors: [{ message: `Compiler error: ${e}` }],
      warnings: ctx.warnings,
    };
  }
}

// ============================================
// Code Emission Helpers
// ============================================

function emit(ctx: CompileContext, line: string) {
  const indentStr = "  ".repeat(ctx.indent);
  ctx.output.push(indentStr + line);
}

function emitLine(ctx: CompileContext) {
  ctx.output.push("");
}

function emitHeader(ctx: CompileContext) {
  emit(ctx, "// Generated by Forvanced Script Compiler");
  emit(ctx, `// Script: ${ctx.script.name}`);
  emit(ctx, `// Generated at: ${new Date().toISOString()}`);
  emitLine(ctx);
  emit(ctx, "'use strict';");
  emitLine(ctx);
}

function emitUIState(ctx: CompileContext) {
  emit(ctx, "// UI Component State");
  emit(ctx, "const uiState = {");
  ctx.indent++;

  for (const component of ctx.uiComponents) {
    const defaultValue = getDefaultValueForComponent(component);
    emit(ctx, `'${component.id}': ${JSON.stringify(defaultValue)},`);
  }

  ctx.indent--;
  emit(ctx, "};");
  emitLine(ctx);

  // Helper functions for UI access
  emit(ctx, "function getUIValue(componentId) {");
  ctx.indent++;
  emit(ctx, "return uiState[componentId];");
  ctx.indent--;
  emit(ctx, "}");
  emitLine(ctx);

  emit(ctx, "function setUIValue(componentId, value) {");
  ctx.indent++;
  emit(ctx, "uiState[componentId] = value;");
  emit(ctx, "// Notify host about UI change");
  emit(ctx, "send({ type: 'ui_value_changed', componentId, value });");
  ctx.indent--;
  emit(ctx, "}");
  emitLine(ctx);
}

function getDefaultValueForComponent(component: UIComponent): unknown {
  switch (component.type) {
    case "toggle":
      return (component.props.defaultValue as boolean) ?? false;
    case "slider":
      return (component.props.defaultValue as number) ?? 0;
    case "input":
      return (component.props.defaultValue as string) ?? "";
    case "dropdown":
      return (component.props.defaultValue as string) ?? "";
    case "button":
      return false; // Button has no persistent value
    default:
      return null;
  }
}

function emitEventHandler(ctx: CompileContext, eventNode: ScriptNode) {
  const handlerName = getEventHandlerName(eventNode);

  emit(ctx, `// Event Handler: ${eventNode.label}`);
  emit(ctx, `function ${handlerName}(eventData) {`);
  ctx.indent++;

  // Set up output values for event node
  setupEventNodeOutputs(ctx, eventNode);

  // Follow the flow from this event node
  compileFlowFromNode(ctx, eventNode, "exec");

  ctx.indent--;
  emit(ctx, "}");
  emitLine(ctx);
}

function getEventHandlerName(eventNode: ScriptNode): string {
  switch (eventNode.type) {
    case "event_ui":
      const componentId = eventNode.config.componentId as string;
      const eventType = eventNode.config.eventType as string;
      return `onUI_${sanitizeId(componentId)}_${eventType}`;
    case "event_attach":
      return "onAttach";
    case "event_detach":
      return "onDetach";
    case "event_hotkey":
      const hotkey = eventNode.config.hotkey as string;
      return `onHotkey_${sanitizeId(hotkey)}`;
    case "event_interval":
      return `onInterval_${eventNode.id.substring(0, 8)}`;
    default:
      return `onEvent_${eventNode.id.substring(0, 8)}`;
  }
}

function sanitizeId(id: string): string {
  return id.replace(/[^a-zA-Z0-9_]/g, "_");
}

function setupEventNodeOutputs(ctx: CompileContext, eventNode: ScriptNode) {
  const outputs = new Map<string, string>();

  switch (eventNode.type) {
    case "event_ui":
      outputs.set("value", "eventData.value");
      outputs.set("componentId", `'${eventNode.config.componentId}'`);
      break;
    case "event_attach":
      outputs.set("processName", "eventData.processName");
      outputs.set("pid", "eventData.pid");
      break;
    case "event_interval":
      outputs.set("tick", "eventData.tick");
      break;
  }

  ctx.nodeOutputs.set(eventNode.id, outputs);
}

function compileFlowFromNode(
  ctx: CompileContext,
  node: ScriptNode,
  outputPortName: string,
) {
  // Find connection from this port
  const connection = ctx.script.connections.find(
    (c) =>
      c.fromNodeId === node.id &&
      node.outputs.find((p) => p.id === c.fromPortId)?.name === outputPortName,
  );

  if (!connection) return;

  const nextNode = ctx.script.nodes.find((n) => n.id === connection.toNodeId);
  if (!nextNode) return;

  compileNode(ctx, nextNode);
}

function compileNode(ctx: CompileContext, node: ScriptNode) {
  // Avoid infinite loops
  if (ctx.visitedNodes.has(node.id)) {
    ctx.warnings.push(
      `Potential infinite loop detected at node ${node.label}`,
    );
    return;
  }

  // Compute value inputs for this node
  const inputs = resolveNodeInputs(ctx, node);

  switch (node.type) {
    case "log":
      compileLogNode(ctx, node, inputs);
      break;
    case "if":
      compileIfNode(ctx, node, inputs);
      break;
    case "delay":
      compileDelayNode(ctx, node, inputs);
      break;
    case "memory_read":
      compileMemoryReadNode(ctx, node, inputs);
      break;
    case "memory_write":
      compileMemoryWriteNode(ctx, node, inputs);
      break;
    case "set_variable":
      compileSetVariableNode(ctx, node, inputs);
      break;
    case "ui_get_value":
      compileUIGetValueNode(ctx, node, inputs);
      break;
    case "ui_set_value":
      compileUISetValueNode(ctx, node, inputs);
      break;
    case "math":
      compileMathNode(ctx, node, inputs);
      break;
    case "compare":
      compileCompareNode(ctx, node, inputs);
      break;
    case "pointer_add":
      compilePointerAddNode(ctx, node, inputs);
      break;
    case "get_module":
      compileGetModuleNode(ctx, node, inputs);
      break;
    case "find_symbol":
      compileFindSymbolNode(ctx, node, inputs);
      break;
    case "notify":
      compileNotifyNode(ctx, node, inputs);
      break;
    default:
      // For unsupported nodes, emit a comment and continue
      emit(ctx, `// TODO: ${node.type} (${node.label})`);
      compileFlowFromNode(ctx, node, "exec");
  }
}

function resolveNodeInputs(
  ctx: CompileContext,
  node: ScriptNode,
): Map<string, string> {
  const inputs = new Map<string, string>();

  for (const inputPort of node.inputs) {
    if (inputPort.type === "flow") continue;

    // Find connection to this input
    const connection = ctx.script.connections.find(
      (c) => c.toNodeId === node.id && c.toPortId === inputPort.id,
    );

    if (connection) {
      // Get value from connected node's output
      const sourceNode = ctx.script.nodes.find(
        (n) => n.id === connection.fromNodeId,
      );
      if (sourceNode) {
        const sourceOutputs = getNodeOutputExpressions(ctx, sourceNode);
        const sourcePort = sourceNode.outputs.find(
          (p) => p.id === connection.fromPortId,
        );
        if (sourcePort && sourceOutputs.has(sourcePort.name)) {
          inputs.set(inputPort.name, sourceOutputs.get(sourcePort.name)!);
        }
      }
    }
  }

  return inputs;
}

function getNodeOutputExpressions(
  ctx: CompileContext,
  node: ScriptNode,
): Map<string, string> {
  // Check if we already computed outputs for this node
  if (ctx.nodeOutputs.has(node.id)) {
    return ctx.nodeOutputs.get(node.id)!;
  }

  const outputs = new Map<string, string>();

  // Compute outputs based on node type
  switch (node.type) {
    case "const_string":
      outputs.set("value", JSON.stringify(node.config.value as string));
      break;
    case "const_number":
      outputs.set("value", String(node.config.value as number));
      break;
    case "const_boolean":
      outputs.set("value", String(node.config.value as boolean));
      break;
    case "const_pointer":
      outputs.set("value", `ptr('${node.config.value}')`);
      break;
    case "get_variable":
      const varName = ctx.variables.get(node.config.variableId as string);
      outputs.set("value", varName ?? "undefined");
      break;
    case "ui_get_value":
      outputs.set(
        "value",
        `getUIValue('${node.config.componentId}')`,
      );
      outputs.set("componentId", `'${node.config.componentId}'`);
      break;
    case "math":
      const mathInputs = resolveNodeInputs(ctx, node);
      const a = mathInputs.get("a") ?? "0";
      const b = mathInputs.get("b") ?? "0";
      const op = node.config.operation as string;
      outputs.set("result", compileMathOperation(a, b, op));
      break;
    case "compare":
      const cmpInputs = resolveNodeInputs(ctx, node);
      const ca = cmpInputs.get("a") ?? "null";
      const cb = cmpInputs.get("b") ?? "null";
      const cmpOp = node.config.operation as string;
      outputs.set("result", compileCompareOperation(ca, cb, cmpOp));
      break;
    case "pointer_add":
      const ptrInputs = resolveNodeInputs(ctx, node);
      const ptr = ptrInputs.get("pointer") ?? "ptr(0)";
      const offset = ptrInputs.get("offset") ?? "0";
      outputs.set("result", `${ptr}.add(${offset})`);
      break;
    case "array_length":
      const arrInputs = resolveNodeInputs(ctx, node);
      const arr = arrInputs.get("array") ?? "[]";
      outputs.set("length", `${arr}.length`);
      break;
    default:
      // For nodes with outputs we haven't handled, emit placeholder
      for (const output of node.outputs) {
        if (output.type === "value") {
          outputs.set(output.name, `/* ${node.type}.${output.name} */`);
        }
      }
  }

  ctx.nodeOutputs.set(node.id, outputs);
  return outputs;
}

// ============================================
// Node Compilation Functions
// ============================================

function compileLogNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const message = inputs.get("message") ?? '""';
  emit(ctx, `console.log(${message});`);
  compileFlowFromNode(ctx, node, "exec");
}

function compileIfNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const condition = inputs.get("condition") ?? "false";

  emit(ctx, `if (${condition}) {`);
  ctx.indent++;
  compileFlowFromNode(ctx, node, "true");
  ctx.indent--;
  emit(ctx, "} else {");
  ctx.indent++;
  compileFlowFromNode(ctx, node, "false");
  ctx.indent--;
  emit(ctx, "}");
}

function compileDelayNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const ms = inputs.get("ms") ?? String(node.config.ms ?? 100);
  emit(ctx, `Thread.sleep(${ms} / 1000);`);
  compileFlowFromNode(ctx, node, "exec");
}

function compileMemoryReadNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const address = inputs.get("address") ?? "ptr(0)";
  const valueType = (node.config.valueType as string) ?? "int32";
  const readMethod = getReadMethodForType(valueType);

  const varName = `_read_${node.id.substring(0, 8)}`;
  emit(ctx, `const ${varName} = ${address}.${readMethod}();`);

  // Store output for downstream nodes
  const outputs = new Map<string, string>();
  outputs.set("value", varName);
  ctx.nodeOutputs.set(node.id, outputs);

  compileFlowFromNode(ctx, node, "exec");
}

function compileMemoryWriteNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const address = inputs.get("address") ?? "ptr(0)";
  const value = inputs.get("value") ?? "0";
  const valueType = (node.config.valueType as string) ?? "int32";
  const writeMethod = getWriteMethodForType(valueType);

  emit(ctx, `${address}.${writeMethod}(${value});`);
  compileFlowFromNode(ctx, node, "exec");
}

function compileSetVariableNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const varId = node.config.variableId as string;
  const value = inputs.get("value") ?? "null";

  let varName = ctx.variables.get(varId);
  if (!varName) {
    varName = `_var_${varId.substring(0, 8)}`;
    ctx.variables.set(varId, varName);
    emit(ctx, `let ${varName} = ${value};`);
  } else {
    emit(ctx, `${varName} = ${value};`);
  }

  // Store output for chaining
  const outputs = new Map<string, string>();
  outputs.set("value", varName);
  ctx.nodeOutputs.set(node.id, outputs);

  compileFlowFromNode(ctx, node, "exec");
}

function compileUIGetValueNode(
  ctx: CompileContext,
  node: ScriptNode,
  _inputs: Map<string, string>,
) {
  const componentId = node.config.componentId as string;

  const outputs = new Map<string, string>();
  outputs.set("value", `getUIValue('${componentId}')`);
  outputs.set("componentId", `'${componentId}'`);
  ctx.nodeOutputs.set(node.id, outputs);
}

function compileUISetValueNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const componentId = node.config.componentId as string;
  const value = inputs.get("value") ?? "null";

  emit(ctx, `setUIValue('${componentId}', ${value});`);
  compileFlowFromNode(ctx, node, "exec");
}

function compileMathNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const a = inputs.get("a") ?? "0";
  const b = inputs.get("b") ?? "0";
  const op = node.config.operation as string;

  const result = compileMathOperation(a, b, op);
  const varName = `_math_${node.id.substring(0, 8)}`;
  emit(ctx, `const ${varName} = ${result};`);

  const outputs = new Map<string, string>();
  outputs.set("result", varName);
  ctx.nodeOutputs.set(node.id, outputs);
}

function compileMathOperation(a: string, b: string, op: string): string {
  switch (op) {
    case "add":
      return `(${a} + ${b})`;
    case "subtract":
      return `(${a} - ${b})`;
    case "multiply":
      return `(${a} * ${b})`;
    case "divide":
      return `(${a} / ${b})`;
    case "modulo":
      return `(${a} % ${b})`;
    case "power":
      return `Math.pow(${a}, ${b})`;
    default:
      return `(${a} + ${b})`;
  }
}

function compileCompareNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const a = inputs.get("a") ?? "null";
  const b = inputs.get("b") ?? "null";
  const op = node.config.operation as string;

  const result = compileCompareOperation(a, b, op);
  const varName = `_cmp_${node.id.substring(0, 8)}`;
  emit(ctx, `const ${varName} = ${result};`);

  const outputs = new Map<string, string>();
  outputs.set("result", varName);
  ctx.nodeOutputs.set(node.id, outputs);
}

function compileCompareOperation(a: string, b: string, op: string): string {
  switch (op) {
    case "equals":
      return `(${a} === ${b})`;
    case "not_equals":
      return `(${a} !== ${b})`;
    case "less_than":
      return `(${a} < ${b})`;
    case "less_or_equal":
      return `(${a} <= ${b})`;
    case "greater_than":
      return `(${a} > ${b})`;
    case "greater_or_equal":
      return `(${a} >= ${b})`;
    default:
      return `(${a} === ${b})`;
  }
}

function compilePointerAddNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const pointer = inputs.get("pointer") ?? "ptr(0)";
  const offset = inputs.get("offset") ?? "0";

  const varName = `_ptr_${node.id.substring(0, 8)}`;
  emit(ctx, `const ${varName} = ${pointer}.add(${offset});`);

  const outputs = new Map<string, string>();
  outputs.set("result", varName);
  ctx.nodeOutputs.set(node.id, outputs);
}

function compileGetModuleNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const name = inputs.get("name") ?? '""';
  const varName = `_mod_${node.id.substring(0, 8)}`;

  emit(ctx, `const ${varName} = Process.findModuleByName(${name});`);

  const outputs = new Map<string, string>();
  outputs.set("module", varName);
  outputs.set("base", `${varName} ? ${varName}.base : ptr(0)`);
  outputs.set("size", `${varName} ? ${varName}.size : 0`);
  ctx.nodeOutputs.set(node.id, outputs);

  compileFlowFromNode(ctx, node, "exec");
}

function compileFindSymbolNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const moduleName = inputs.get("module") ?? '""';
  const symbolName = inputs.get("symbol") ?? '""';
  const varName = `_sym_${node.id.substring(0, 8)}`;

  emit(
    ctx,
    `const ${varName} = Module.findExportByName(${moduleName}, ${symbolName});`,
  );

  const outputs = new Map<string, string>();
  outputs.set("address", varName);
  ctx.nodeOutputs.set(node.id, outputs);

  compileFlowFromNode(ctx, node, "exec");
}

function compileNotifyNode(
  ctx: CompileContext,
  node: ScriptNode,
  inputs: Map<string, string>,
) {
  const title = inputs.get("title") ?? '"Notification"';
  const message = inputs.get("message") ?? '""';
  const level = (node.config.level as string) ?? "info";

  emit(
    ctx,
    `send({ type: 'notify', level: '${level}', title: ${title}, message: ${message} });`,
  );
  compileFlowFromNode(ctx, node, "exec");
}

// ============================================
// Helper Functions
// ============================================

function getReadMethodForType(valueType: string): string {
  const methodMap: Record<string, string> = {
    int8: "readS8",
    uint8: "readU8",
    int16: "readS16",
    uint16: "readU16",
    int32: "readS32",
    uint32: "readU32",
    int64: "readS64",
    uint64: "readU64",
    float: "readFloat",
    double: "readDouble",
    pointer: "readPointer",
  };
  return methodMap[valueType] ?? "readS32";
}

function getWriteMethodForType(valueType: string): string {
  const methodMap: Record<string, string> = {
    int8: "writeS8",
    uint8: "writeU8",
    int16: "writeS16",
    uint16: "writeU16",
    int32: "writeS32",
    uint32: "writeU32",
    int64: "writeS64",
    uint64: "writeU64",
    float: "writeFloat",
    double: "writeDouble",
    pointer: "writePointer",
  };
  return methodMap[valueType] ?? "writeS32";
}

function emitRpcExports(ctx: CompileContext, eventNodes: ScriptNode[]) {
  emit(ctx, "// RPC Exports for host communication");
  emit(ctx, "rpc.exports = {");
  ctx.indent++;

  // UI event handlers
  const uiEvents = eventNodes.filter((n) => n.type === "event_ui");
  for (const event of uiEvents) {
    const handlerName = getEventHandlerName(event);
    const componentId = event.config.componentId as string;
    const eventType = event.config.eventType as string;

    emit(ctx, `// UI Event: ${componentId} - ${eventType}`);
    emit(ctx, `${handlerName}: function(value) {`);
    ctx.indent++;
    emit(ctx, `uiState['${componentId}'] = value;`);
    emit(ctx, `${handlerName}({ value, componentId: '${componentId}' });`);
    ctx.indent--;
    emit(ctx, "},");
    emitLine(ctx);
  }

  // Attach/Detach handlers
  if (eventNodes.some((n) => n.type === "event_attach")) {
    emit(ctx, "onAttach: function(processName, pid) {");
    ctx.indent++;
    emit(ctx, "onAttach({ processName, pid });");
    ctx.indent--;
    emit(ctx, "},");
    emitLine(ctx);
  }

  if (eventNodes.some((n) => n.type === "event_detach")) {
    emit(ctx, "onDetach: function() {");
    ctx.indent++;
    emit(ctx, "onDetach({});");
    ctx.indent--;
    emit(ctx, "},");
    emitLine(ctx);
  }

  // Generic UI value setter (called from host)
  emit(ctx, "setUIValue: function(componentId, value) {");
  ctx.indent++;
  emit(ctx, "setUIValue(componentId, value);");
  ctx.indent--;
  emit(ctx, "},");
  emitLine(ctx);

  // Get all UI values
  emit(ctx, "getUIState: function() {");
  ctx.indent++;
  emit(ctx, "return uiState;");
  ctx.indent--;
  emit(ctx, "},");

  ctx.indent--;
  emit(ctx, "};");
  emitLine(ctx);
}

function emitFooter(ctx: CompileContext) {
  emit(ctx, "// Script initialization");
  emit(ctx, "console.log('[Forvanced] Script loaded');");
}
