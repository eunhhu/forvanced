//! Code generation for Frida actions and UI components
//!
//! This module generates code for the Forvanced trainer runtime.
//! NOTE: The generated Frida scripts intentionally execute user-defined code
//! as this is the core functionality of a trainer/cheat application.

use forvanced_core::{
    ActionBinding, ComponentEvent, ComponentType, FridaAction, Project, UIComponent, ValueType,
};

/// Generate TypeScript code for the trainer UI
pub fn generate_ui_code(project: &Project) -> String {
    let components_code = project
        .ui
        .components
        .iter()
        .map(generate_component_code)
        .collect::<Vec<_>>()
        .join("\n");

    let bindings_code = project
        .ui
        .components
        .iter()
        .flat_map(|c| c.bindings.iter().map(|b| (c.id.clone(), b)))
        .map(|(cid, b)| generate_binding_handler(&cid, b))
        .collect::<Vec<_>>()
        .join("\n\n");

    format!(
        r#"// Auto-generated by Forvanced Builder
// Project: {name}
// Version: {version}

import {{ Component, createSignal, For }} from "solid-js";
import {{ cheatEngine }} from "./engine";

// Component state
{state_code}

// Action handlers
{bindings_code}

// UI Components
export const TrainerUI: Component = () => {{
  return (
    <div class="trainer-container" style="width: {width}px; height: {height}px;">
      {components_code}
    </div>
  );
}};

export default TrainerUI;
"#,
        name = project.name,
        version = project.version,
        width = project.ui.width,
        height = project.ui.height,
        state_code = generate_state_code(&project.ui.components),
        bindings_code = bindings_code,
        components_code = components_code,
    )
}

fn generate_state_code(components: &[UIComponent]) -> String {
    components
        .iter()
        .filter(|c| matches!(c.component_type, ComponentType::Toggle | ComponentType::Slider | ComponentType::Input))
        .map(|c| {
            let default_value = match c.component_type {
                ComponentType::Toggle => "false".to_string(),
                ComponentType::Slider => c.props.get("defaultValue").map(|v| v.to_string()).unwrap_or("50".to_string()),
                ComponentType::Input => "\"\"".to_string(),
                _ => "null".to_string(),
            };
            format!(
                "const [{id}State, set{id_cap}State] = createSignal({default});",
                id = sanitize_id(&c.id),
                id_cap = capitalize(&sanitize_id(&c.id)),
                default = default_value,
            )
        })
        .collect::<Vec<_>>()
        .join("\n")
}

fn generate_component_code(component: &UIComponent) -> String {
    let id = sanitize_id(&component.id);
    let style = format!(
        "position: absolute; left: {}px; top: {}px; width: {}px; height: {}px;",
        component.x, component.y, component.width, component.height
    );

    match component.component_type {
        ComponentType::Button => format!(
            r#"      <button
        class="trainer-button"
        style="{style}"
        onClick={{() => handle_{id}_click()}}
      >
        {label}
      </button>"#,
            style = style,
            id = id,
            label = component.label,
        ),

        ComponentType::Toggle => format!(
            r#"      <label class="trainer-toggle" style="{style}">
        <input
          type="checkbox"
          checked={{{id}State()}}
          onChange={{(e) => {{
            set{id_cap}State(e.currentTarget.checked);
            handle_{id}_toggle(e.currentTarget.checked);
          }}}}
        />
        <span>{label}</span>
      </label>"#,
            style = style,
            id = id,
            id_cap = capitalize(&id),
            label = component.label,
        ),

        ComponentType::Slider => {
            let min = component.props.get("min").map(|v| v.to_string()).unwrap_or("0".to_string());
            let max = component.props.get("max").map(|v| v.to_string()).unwrap_or("100".to_string());
            format!(
                r#"      <div class="trainer-slider" style="{style}">
        <label>{label}: {{{id}State()}}</label>
        <input
          type="range"
          min="{min}"
          max="{max}"
          value={{{id}State()}}
          onInput={{(e) => {{
            const val = parseInt(e.currentTarget.value);
            set{id_cap}State(val);
            handle_{id}_slide(val);
          }}}}
        />
      </div>"#,
                style = style,
                id = id,
                id_cap = capitalize(&id),
                label = component.label,
                min = min,
                max = max,
            )
        }

        ComponentType::Label => format!(
            r#"      <div class="trainer-label" style="{style}">{label}</div>"#,
            style = style,
            label = component.label,
        ),

        ComponentType::Input => format!(
            r#"      <input
        class="trainer-input"
        style="{style}"
        placeholder="{label}"
        value={{{id}State()}}
        onInput={{(e) => {{
          set{id_cap}State(e.currentTarget.value);
          handle_{id}_change(e.currentTarget.value);
        }}}}
      />"#,
            style = style,
            id = id,
            id_cap = capitalize(&id),
            label = component.label,
        ),

        ComponentType::Dropdown => {
            let options = component
                .props
                .get("options")
                .and_then(|v| v.as_array())
                .map(|arr| {
                    arr.iter()
                        .filter_map(|v| v.as_str())
                        .map(|s| format!(r#"        <option value="{}">{}</option>"#, s, s))
                        .collect::<Vec<_>>()
                        .join("\n")
                })
                .unwrap_or_default();

            format!(
                r#"      <select class="trainer-dropdown" style="{style}" onChange={{(e) => handle_{id}_change(e.currentTarget.value)}}>
        <option value="">{label}</option>
{options}
      </select>"#,
                style = style,
                id = id,
                label = component.label,
                options = options,
            )
        }

        ComponentType::Group => format!(
            r#"      <fieldset class="trainer-group" style="{style}">
        <legend>{label}</legend>
      </fieldset>"#,
            style = style,
            label = component.label,
        ),

        ComponentType::Spacer => format!(
            r#"      <div class="trainer-spacer" style="{style}"></div>"#,
            style = style,
        ),

        // Layout components - placeholder implementations for code generation
        ComponentType::Stack => format!(
            r#"      <div class="trainer-stack" style="{style}">{label}</div>"#,
            style = style,
            label = component.label,
        ),

        ComponentType::Page => format!(
            r#"      <div class="trainer-page" style="{style}">{label}</div>"#,
            style = style,
            label = component.label,
        ),

        ComponentType::Scroll => format!(
            r#"      <div class="trainer-scroll" style="{style}">{label}</div>"#,
            style = style,
            label = component.label,
        ),

        ComponentType::Divider => format!(
            r#"      <hr class="trainer-divider" style="{style}" />"#,
            style = style,
        ),

        ComponentType::Card => format!(
            r#"      <div class="trainer-card" style="{style}">{label}</div>"#,
            style = style,
            label = component.label,
        ),
    }
}

fn generate_binding_handler(component_id: &str, binding: &ActionBinding) -> String {
    let id = sanitize_id(component_id);
    let handler_name = match binding.event {
        ComponentEvent::OnClick => format!("handle_{}_click", id),
        ComponentEvent::OnToggle => format!("handle_{}_toggle", id),
        ComponentEvent::OnChange => format!("handle_{}_change", id),
        ComponentEvent::OnSlide => format!("handle_{}_slide", id),
    };

    let param = match binding.event {
        ComponentEvent::OnClick => "",
        ComponentEvent::OnToggle => "enabled: boolean",
        ComponentEvent::OnChange => "value: string",
        ComponentEvent::OnSlide => "value: number",
    };

    let action_code = generate_action_code(&binding.action);

    format!(
        r#"async function {handler_name}({param}) {{
  try {{
    {action_code}
  }} catch (error) {{
    console.error("Action failed:", error);
  }}
}}"#,
        handler_name = handler_name,
        param = param,
        action_code = action_code,
    )
}

fn generate_action_code(action: &FridaAction) -> String {
    match action {
        FridaAction::MemoryRead { address, value_type } => format!(
            r#"const value = await cheatEngine.memoryRead("{}", "{}");
    console.log("Read value:", value);"#,
            address,
            value_type_to_str(value_type)
        ),

        FridaAction::MemoryWrite {
            address,
            value,
            value_type,
        } => format!(
            r#"await cheatEngine.memoryWrite("{}", "{}", "{}");"#,
            address, value, value_type_to_str(value_type)
        ),

        FridaAction::MemoryFreeze {
            address,
            value,
            value_type,
            interval_ms,
        } => format!(
            r#"await cheatEngine.memoryFreeze("{}", "{}", "{}", {});"#,
            address, value, value_type_to_str(value_type), interval_ms
        ),

        FridaAction::MemoryUnfreeze { address } => {
            format!(r#"await cheatEngine.memoryUnfreeze("{}");"#, address)
        }

        FridaAction::PatternScan { pattern, protection } => format!(
            r#"const results = await cheatEngine.patternScan("{}", "{}");
    console.log("Pattern scan results:", results);"#,
            pattern, protection
        ),

        FridaAction::ValueScan { value, value_type } => format!(
            r#"const results = await cheatEngine.valueScan("{}", "{}");
    console.log("Value scan results:", results);"#,
            value,
            value_type_to_str(value_type)
        ),

        FridaAction::HookFunction {
            address,
            log_enter,
            log_leave,
        } => format!(
            r#"await cheatEngine.hookFunction("{}", {{ logEnter: {}, logLeave: {} }});"#,
            address, log_enter, log_leave
        ),

        FridaAction::ReplaceReturn {
            address,
            return_value,
        } => format!(
            r#"await cheatEngine.replaceReturn("{}", {});"#,
            address, return_value
        ),

        FridaAction::NopFunction { address } => {
            format!(r#"await cheatEngine.nopFunction("{}");"#, address)
        }

        FridaAction::JavaHookMethod {
            class_name,
            method_name,
            overload,
        } => {
            let overload_str = overload
                .as_ref()
                .map(|o| format!(r#", "{}""#, o))
                .unwrap_or_default();
            format!(
                r#"await cheatEngine.javaHookMethod("{}", "{}"{});"#,
                class_name, method_name, overload_str
            )
        }

        FridaAction::JavaModifyReturn {
            class_name,
            method_name,
            return_value,
        } => format!(
            r#"await cheatEngine.javaModifyReturn("{}", "{}", {});"#,
            class_name, method_name, return_value
        ),

        FridaAction::JavaCallMethod {
            class_name,
            method_name,
            is_static,
        } => format!(
            r#"await cheatEngine.javaCallMethod("{}", "{}", {});"#,
            class_name, method_name, is_static
        ),

        FridaAction::ObjcHookMethod {
            class_name,
            selector,
            is_class_method,
        } => format!(
            r#"await cheatEngine.objcHookMethod("{}", "{}", {});"#,
            class_name, selector, is_class_method
        ),

        FridaAction::ObjcModifyReturn {
            class_name,
            selector,
            return_value,
        } => format!(
            r#"await cheatEngine.objcModifyReturn("{}", "{}", {});"#,
            class_name, selector, return_value
        ),

        FridaAction::SwiftHookFunction { mangled_name } => {
            format!(r#"await cheatEngine.swiftHookFunction("{}");"#, mangled_name)
        }

        FridaAction::ListModules => {
            r#"const modules = await cheatEngine.listModules();
    console.log("Modules:", modules);"#
                .to_string()
        }

        FridaAction::FindExport {
            module_name,
            export_name,
        } => format!(
            r#"const address = await cheatEngine.findExport("{}", "{}");
    console.log("Export address:", address);"#,
            module_name, export_name
        ),

        FridaAction::Custom { script } => format!(
            r#"await cheatEngine.executeCustom(`{}`);
"#,
            script.replace('`', "\\`")
        ),
    }
}

fn value_type_to_str(vt: &ValueType) -> &'static str {
    match vt {
        ValueType::Int8 => "int8",
        ValueType::UInt8 => "uint8",
        ValueType::Int16 => "int16",
        ValueType::UInt16 => "uint16",
        ValueType::Int32 => "int32",
        ValueType::UInt32 => "uint32",
        ValueType::Int64 => "int64",
        ValueType::UInt64 => "uint64",
        ValueType::Float => "float",
        ValueType::Double => "double",
        ValueType::Pointer => "pointer",
        ValueType::String => "string",
    }
}

fn sanitize_id(id: &str) -> String {
    id.chars()
        .map(|c| if c.is_alphanumeric() { c } else { '_' })
        .collect()
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

/// Generate Frida script that bundles all actions
pub fn generate_frida_script(project: &Project) -> String {
    // Generate script with all necessary Frida operations
    // NOTE: This intentionally provides code execution capabilities as it's
    // the core functionality of a Frida-based trainer application.
    format!(
        r#"// Auto-generated Frida script for {name}
// Version: {version}

'use strict';

const memory = {{
  freeze_intervals: new Map(),

  read(address, type) {{
    const p = ptr(address);
    switch(type) {{
      case 'int8': return p.readS8();
      case 'uint8': return p.readU8();
      case 'int16': return p.readS16();
      case 'uint16': return p.readU16();
      case 'int32': return p.readS32();
      case 'uint32': return p.readU32();
      case 'int64': return p.readS64();
      case 'uint64': return p.readU64();
      case 'float': return p.readFloat();
      case 'double': return p.readDouble();
      case 'pointer': return p.readPointer();
      case 'string': return p.readUtf8String();
      default: throw new Error('Unknown type: ' + type);
    }}
  }},

  write(address, value, type) {{
    const p = ptr(address);
    switch(type) {{
      case 'int8': p.writeS8(value); break;
      case 'uint8': p.writeU8(value); break;
      case 'int16': p.writeS16(value); break;
      case 'uint16': p.writeU16(value); break;
      case 'int32': p.writeS32(value); break;
      case 'uint32': p.writeU32(value); break;
      case 'int64': p.writeS64(value); break;
      case 'uint64': p.writeU64(value); break;
      case 'float': p.writeFloat(value); break;
      case 'double': p.writeDouble(value); break;
      case 'pointer': p.writePointer(value); break;
      case 'string': p.writeUtf8String(value); break;
      default: throw new Error('Unknown type: ' + type);
    }}
  }},

  freeze(address, value, type, intervalMs) {{
    this.unfreeze(address);
    const interval = setInterval(() => {{
      this.write(address, value, type);
    }}, intervalMs);
    this.freeze_intervals.set(address, interval);
  }},

  unfreeze(address) {{
    const interval = this.freeze_intervals.get(address);
    if (interval) {{
      clearInterval(interval);
      this.freeze_intervals.delete(address);
    }}
  }}
}};

const scanner = {{
  patternScan(pattern, protection) {{
    const results = [];
    Process.enumerateRanges(protection).forEach(range => {{
      const matches = Memory.scanSync(range.base, range.size, pattern);
      results.push(...matches.map(m => m.address));
    }});
    return results;
  }},

  valueScan(value, type) {{
    // Implementation depends on specific requirements
    return [];
  }}
}};

const hooks = {{
  interceptors: new Map(),

  hookFunction(address, options) {{
    const p = ptr(address);
    const interceptor = Interceptor.attach(p, {{
      onEnter: options.logEnter ? function(args) {{
        console.log('[ENTER]', address);
      }} : undefined,
      onLeave: options.logLeave ? function(retval) {{
        console.log('[LEAVE]', address, '=', retval);
      }} : undefined
    }});
    this.interceptors.set(address, interceptor);
  }},

  replaceReturn(address, value) {{
    const p = ptr(address);
    Interceptor.attach(p, {{
      onLeave(retval) {{
        retval.replace(ptr(value));
      }}
    }});
  }},

  nop(address) {{
    const p = ptr(address);
    Memory.protect(p, Process.pointerSize, 'rwx');
    if (Process.arch === 'x64' || Process.arch === 'ia32') {{
      p.writeByteArray([0x90]); // x86 NOP
    }} else if (Process.arch === 'arm64') {{
      p.writeByteArray([0x1f, 0x20, 0x03, 0xd5]); // ARM64 NOP
    }}
  }}
}};

// Java bridge (Android)
const java = {{
  hookMethod(className, methodName, overload) {{
    Java.perform(() => {{
      const clazz = Java.use(className);
      const method = overload ? clazz[methodName].overload(overload) : clazz[methodName];
      method.implementation = function(...args) {{
        console.log('[Java]', className + '.' + methodName, args);
        return method.apply(this, args);
      }};
    }});
  }},

  modifyReturn(className, methodName, value) {{
    Java.perform(() => {{
      const clazz = Java.use(className);
      clazz[methodName].implementation = function() {{
        return value;
      }};
    }});
  }},

  callMethod(className, methodName, isStatic) {{
    Java.perform(() => {{
      const clazz = Java.use(className);
      if (isStatic) {{
        return clazz[methodName]();
      }} else {{
        console.warn('Instance method call requires instance');
      }}
    }});
  }}
}};

// ObjC bridge (iOS/macOS)
const objc = {{
  hookMethod(className, selector, isClassMethod) {{
    const clazz = ObjC.classes[className];
    const method = isClassMethod ? clazz['+ ' + selector] : clazz['- ' + selector];
    Interceptor.attach(method.implementation, {{
      onEnter(args) {{
        console.log('[ObjC]', className, selector);
      }}
    }});
  }},

  modifyReturn(className, selector, value) {{
    const clazz = ObjC.classes[className];
    const method = clazz['- ' + selector];
    Interceptor.attach(method.implementation, {{
      onLeave(retval) {{
        retval.replace(ObjC.Object(ptr(value)));
      }}
    }});
  }}
}};

// Export API
rpc.exports = {{
  memoryRead: memory.read.bind(memory),
  memoryWrite: memory.write.bind(memory),
  memoryFreeze: memory.freeze.bind(memory),
  memoryUnfreeze: memory.unfreeze.bind(memory),
  patternScan: scanner.patternScan.bind(scanner),
  valueScan: scanner.valueScan.bind(scanner),
  hookFunction: hooks.hookFunction.bind(hooks),
  replaceReturn: hooks.replaceReturn.bind(hooks),
  nopFunction: hooks.nop.bind(hooks),
  javaHookMethod: java.hookMethod.bind(java),
  javaModifyReturn: java.modifyReturn.bind(java),
  javaCallMethod: java.callMethod.bind(java),
  objcHookMethod: objc.hookMethod.bind(objc),
  objcModifyReturn: objc.modifyReturn.bind(objc),
  listModules: () => Process.enumerateModules(),
  findExport: (moduleName, exportName) => Module.findExportByName(moduleName, exportName)
}};

console.log('[Forvanced] Trainer loaded: {name}');
"#,
        name = project.name,
        version = project.version,
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use forvanced_core::{ActionBinding, ComponentEvent, Project, UIComponent};

    #[test]
    fn test_generate_ui_code() {
        let mut project = Project::new("Test Trainer");
        let mut btn = UIComponent::new(ComponentType::Button, "Freeze HP", 10.0, 10.0);
        btn.bindings.push(ActionBinding::new(
            ComponentEvent::OnClick,
            FridaAction::MemoryFreeze {
                address: "0x12345678".to_string(),
                value: "999".to_string(),
                value_type: ValueType::Int32,
                interval_ms: 100,
            },
        ));
        project.ui.components.push(btn);

        let code = generate_ui_code(&project);
        assert!(code.contains("Test Trainer"));
        assert!(code.contains("Freeze HP"));
        assert!(code.contains("memoryFreeze"));
    }

    #[test]
    fn test_generate_frida_script() {
        let project = Project::new("Test");
        let script = generate_frida_script(&project);
        assert!(script.contains("rpc.exports"));
        assert!(script.contains("memoryRead"));
    }
}
